var documenterSearchIndex = {"docs":
[{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"EditURL = \"https://github.com/gdalle/FastPriorityQueues.jl/blob/main/test/benchmarks.jl\"","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\nusing DataStructures\nusing FastPriorityQueues\nusing Graphs\nusing Test","category":"page"},{"location":"benchmarks/#Setup","page":"Benchmarks","title":"Setup","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"An interesting way to benchmark priority queues is to use them inside Dijkstra's algorithm, for which they play a key role in performance.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"According to this technical report, there are two possible implementations:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"one that updates the priority values of vertices inside the queue\none that reinserts them with new priority values, potentially creating duplicates","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We reproduce both of them below.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"function dijkstra_priority_updates!(\n    q::Q, g::AbstractGraph{T}, s::Integer, w=weights(g)\n) where {Q,T}\n    d = fill(Inf, nv(g))\n    d[s] = 0.\n    enqueue!(q, s, 0.)\n    while !isempty(q)\n        u, k = first(q)\n        dequeue!(q)\n        d[u] = k\n        for v in outneighbors(g, u)\n            if d[u] + w[u, v] < d[v]\n                d[v] = d[u] + w[u, v]\n                d[v] == Inf ? enqueue!(q, v, d[v]) : q[v] = d[v]\n            end\n        end\n    end\n    return d\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"function dijkstra_no_priority_updates!(\n    q::Q, g::AbstractGraph{T}, s::Integer, w=weights(g)\n) where {Q,T}\n    d = fill(Inf, nv(g))\n    d[s] = 0.\n    enqueue!(q, s, 0.)\n    while !isempty(q)\n        u, k = first(q)\n        dequeue!(q)\n        if k <= d[u]\n            d[u] = k\n            for v in outneighbors(g, u)\n                if d[u] + w[u, v] < d[v]\n                    d[v] = d[u] + w[u, v]\n                    enqueue!(q, v, d[v])\n                end\n            end\n        end\n    end\n    return d\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our types VectorPriorityQueue and SortedVectorPriorityQueue do not support priority updates, but on the other hand they have fast enqueueing and dequeueing routines. We hope it will be sufficient to outperform DataStructures.PriorityQueue on the following test example.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"function test_dijkstra(n, qtype; priority_updates)\n    g = Graphs.grid([n, n])\n    q = qtype()\n    if priority_updates\n        return dijkstra_priority_updates!(q, g, 1)\n    else\n        return dijkstra_no_priority_updates!(q, g, 1)\n    end\nend;\nnothing #hide","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Let us first verify that the outputs are coherent with one another.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"d1 = test_dijkstra(10, PriorityQueue{Int,Float64}; priority_updates=true)[end];\nd2 = test_dijkstra(10, PriorityQueue{Int,Float64}; priority_updates=false)[end];\nd3 = test_dijkstra(10, VectorPriorityQueue{Int,Float64}; priority_updates=false)[end];\nd4 = test_dijkstra(10, SortedVectorPriorityQueue{Int,Float64}; priority_updates=false)[end];\n@test d1 ≈ d2 ≈ d3 ≈ d4","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Now we measure execution time and memory allocations for each of the variants.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"@benchmark test_dijkstra(100, PriorityQueue{Int,Float64}; priority_updates=true)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"@benchmark test_dijkstra(100, PriorityQueue{Int,Float64}; priority_updates=false)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Disabling priority updates does not change the performance when using the standard queue, because insertion is almost as costly as updating. However, the story is very different with our custom queues.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"@benchmark test_dijkstra(100, VectorPriorityQueue{Int,Float64}; priority_updates=false)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"@benchmark test_dijkstra(100, SortedVectorPriorityQueue{Int,Float64}; priority_updates=false)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"warning: TODO\nBenchmark other containers from DataStructures.jl (heaps and dicts).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [FastPriorityQueues]","category":"page"},{"location":"api/#FastPriorityQueues.SortedVectorPriorityQueue","page":"API reference","title":"FastPriorityQueues.SortedVectorPriorityQueue","text":"SortedVectorPriorityQueue{K,V}\n\nPriority queue with keys of type K and priority values of type V, stored as a sorted vector of couples.\n\nFields\n\ndata::Vector{Pair{K,V}}: vector of key-value pairs k => v sorted by increasing value of v.\n\n\n\n\n\n","category":"type"},{"location":"api/#FastPriorityQueues.VectorPriorityQueue","page":"API reference","title":"FastPriorityQueues.VectorPriorityQueue","text":"VectorPriorityQueue{K,V}\n\nPriority queue with keys of type K and priority values of type V, stored as a vector of couples.\n\nFields\n\ndata::Vector{Pair{K,V}}: vector of key-value pairs k => v sorted by increasing arrival time.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataStructures.dequeue!-Tuple{SortedVectorPriorityQueue}","page":"API reference","title":"DataStructures.dequeue!","text":"dequeue!(pq::SortedVectorPriorityQueue)\n\nRemove and return the key k with lowest priority value v. Amortized complexity O(1).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.dequeue!-Tuple{VectorPriorityQueue}","page":"API reference","title":"DataStructures.dequeue!","text":"dequeue!(pq::VectorPriorityQueue)\n\nRemove and return the key k with lowest priority value v. Amortized complexity O(n).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.enqueue!-Union{Tuple{V}, Tuple{K}, Tuple{SortedVectorPriorityQueue{K, V}, K, V}} where {K, V}","page":"API reference","title":"DataStructures.enqueue!","text":"enqueue!(pq::SortedVectorPriorityQueue, k, v)\n\nInsert k => v into the queue pq. Amortized complexity O(log n).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.enqueue!-Union{Tuple{V}, Tuple{K}, Tuple{VectorPriorityQueue{K, V}, K, V}} where {K, V}","page":"API reference","title":"DataStructures.enqueue!","text":"enqueue!(pq::VectorPriorityQueue, k, v)\n\nInsert k => v into the queue pq. Amortized complexity O(1).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FastPriorityQueues","category":"page"},{"location":"#FastPriorityQueues.jl","page":"Home","title":"FastPriorityQueues.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for FastPriorityQueues.jl.","category":"page"},{"location":"#Why-this-package?","page":"Home","title":"Why this package?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The standard PriorityQueue provided by DataStructures.jl relies on a dictionary, which can be inefficient in some cases.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There have been a number of Discourse topics on this issue (2020/07, 2021/01, 2021/09), but sofar it looks like alternative implementations are scattered through specific packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goal of the present package is to make some of these alternatives available under a name that is easily discoverable.","category":"page"}]
}
