var documenterSearchIndex = {"docs":
[{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"EditURL = \"https://github.com/gdalle/FastPriorityQueues.jl/blob/main/test/benchmarks.jl\"","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using DataStructures\nusing FastPriorityQueues\nusing Graphs\nusing Plots\nusing Test","category":"page"},{"location":"benchmarks/#Setup","page":"Benchmarks","title":"Setup","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"An interesting way to benchmark priority queues is to use them inside Dijkstra's algorithm, for which they play a key role in performance.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"According to this technical report, there are two main implementations:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"one that updates the priority values of vertices inside the queue\none that reinserts them with new priority values, potentially creating duplicates","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Graphs.jl uses the first version with a DataStructures.PriorityQueue, so here we code the second one.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"function dijkstra_no_priority_updates!(\n    q::Q, g::AbstractGraph{T}, s::Integer, w=weights(g)\n) where {Q,T}\n    d = fill(Inf, nv(g))\n    d[s] = 0.0\n    enqueue!(q, s, 0.0)\n    while !isempty(q)\n        u, d_u = dequeue_pair!(q)\n        if d_u <= d[u]\n            d[u] = d_u\n            for v in outneighbors(g, u)\n                d_v = d[u] + w[u, v]\n                if d_v < d[v]\n                    enqueue!(q, v, d_v)\n                    d[v] = d_v\n                end\n            end\n        end\n    end\n    return d\nend;\nnothing #hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our custom queue types do not support priority updates, but on the other hand they have fast enqueueing and dequeueing routines, which makes them well-suited for dijkstra_no_priority_updates!.","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our goal is to see in which cases we can be faster than Graphs.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"test_dijkstra(g, qtype) = dijkstra_no_priority_updates!(qtype(), g, 1)[end];\ntest_dijkstra_default(g) = Graphs.dijkstra_shortest_paths(g, 1).dists[end];\nnothing #hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Let us first verify that the outputs of both implementations are coherent.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"g_small = Graphs.grid([10, 10])","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"d1 = test_dijkstra_default(g_small);\nd2 = test_dijkstra(g_small, PriorityQueue{Int,Float64});\nd3 = test_dijkstra(g_small, VectorPriorityQueue{Int,Float64});\nd4 = test_dijkstra(g_small, SortedVectorPriorityQueue{Int,Float64});\nd5 = test_dijkstra(g_small, HeapPriorityQueue{Int,Float64});\n@test d1 ≈ d2 ≈ d3 ≈ d4 ≈ d5","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Now we measure execution time and memory allocations for each of the queue types.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"function compare_dijkstra_versions(n_values)\n    speedups = Dict(\n        \"PriorityQueue\" => Float64[],\n        \"VectorPriorityQueue\" => Float64[],\n        \"SortedVectorPriorityQueue\" => Float64[],\n        \"HeapPriorityQueue\" => Float64[],\n    )\n    for n in n_values\n        @info \"Testing grids of side length $n\"\n        g = Graphs.grid([n, n])\n        t0 = @elapsed for _ in 1:5\n            test_dijkstra_default(g)\n        end\n        t1 = @elapsed for _ in 1:5\n            test_dijkstra(g, PriorityQueue{Int,Float64})\n        end\n        t2 = @elapsed for _ in 1:5\n            test_dijkstra(g, VectorPriorityQueue{Int,Float64})\n        end\n        t3 = @elapsed for _ in 1:5\n            test_dijkstra(g, SortedVectorPriorityQueue{Int,Float64})\n        end\n        t4 = @elapsed for _ in 1:5\n            test_dijkstra(g, HeapPriorityQueue{Int,Float64})\n        end\n        push!(speedups[\"PriorityQueue\"], t0 / t1)\n        push!(speedups[\"VectorPriorityQueue\"], t0 / t2)\n        push!(speedups[\"SortedVectorPriorityQueue\"], t0 / t3)\n        push!(speedups[\"HeapPriorityQueue\"], t0 / t4)\n    end\n    return speedups\nend;\nnothing #hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"To gain precision, we could replace the built-in @elapsed with @belapsed from BenchmarkTools.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"n_values = [10, 100, 1000]\nspeedups = compare_dijkstra_versions(n_values)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Finally, let us plot the results.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"settings = [\n    \"HeapPriorityQueue\", \"SortedVectorPriorityQueue\", \"VectorPriorityQueue\", \"PriorityQueue\"\n]\nplt = plot(;\n    title=\"Dijkstra with no priority updates\",\n    xlabel=\"Grid side length\",\n    ylabel=\"Speedup wrt. Graphs.jl\",\n    ylim=(0, Inf),\n    xticks=(1:length(n_values), string.(n_values)),\n    margin=5Plots.mm,\n)\nfor (k, setting) in enumerate(settings)\n    bar!(\n        plt,\n        (1:length(n_values)) .+ 0.7 * (k - (length(settings) + 1) / 2) / length(settings),\n        speedups[setting];\n        label=setting,\n        bar_width=0.7 / length(settings),\n    )\nend\nplt","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [FastPriorityQueues]","category":"page"},{"location":"api/#FastPriorityQueues.HeapPriorityQueue","page":"API reference","title":"FastPriorityQueues.HeapPriorityQueue","text":"HeapPriorityQueue{K,V}\n\nMin priority queue with keys of type K and priority values of type V, stored using a binary heap from DataStructures.jl.\n\nFields\n\nheap::Heap: heap of key-value pairs k => v ordered by increasing v\n\n\n\n\n\n","category":"type"},{"location":"api/#FastPriorityQueues.SortedVectorPriorityQueue","page":"API reference","title":"FastPriorityQueues.SortedVectorPriorityQueue","text":"SortedVectorPriorityQueue{K,V}\n\nMin priority queue with keys of type K and priority values of type V, stored using a sorted vector of couples.\n\nFields\n\npairs::Vector{Pair{K,V}}: vector of key-value pairs k => v ordered by increasing v.\n\n\n\n\n\n","category":"type"},{"location":"api/#FastPriorityQueues.VectorPriorityQueue","page":"API reference","title":"FastPriorityQueues.VectorPriorityQueue","text":"VectorPriorityQueue{K,V}\n\nMin priority queue with keys of type K and priority values of type V, stored as a vector of couples.\n\nFields\n\npairs::Vector{Pair{K,V}}: vector of key-value pairs k => v in arbitrary order.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataStructures.dequeue!-Tuple{HeapPriorityQueue}","page":"API reference","title":"DataStructures.dequeue!","text":"dequeue!(pq::HeapPriorityQueue)\n\nRemove and return the key k with lowest priority value v. Amortized complexity O(1).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.dequeue!-Tuple{SortedVectorPriorityQueue}","page":"API reference","title":"DataStructures.dequeue!","text":"dequeue!(pq::SortedVectorPriorityQueue)\n\nRemove and return the key k with lowest priority value v. Amortized complexity O(1).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.dequeue!-Tuple{VectorPriorityQueue}","page":"API reference","title":"DataStructures.dequeue!","text":"dequeue!(pq::VectorPriorityQueue)\n\nRemove and return the key k with lowest priority value v. Amortized complexity O(n).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.dequeue_pair!-Tuple{HeapPriorityQueue}","page":"API reference","title":"DataStructures.dequeue_pair!","text":"dequeue_pair!(pq::HeapPriorityQueue)\n\nRemove and return the pair k => v with lowest priority value v. Amortized complexity O(1).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.dequeue_pair!-Tuple{SortedVectorPriorityQueue}","page":"API reference","title":"DataStructures.dequeue_pair!","text":"dequeue_pair!(pq::SortedVectorPriorityQueue)\n\nRemove and return the pair k => v with lowest priority value v. Amortized complexity O(1).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.dequeue_pair!-Tuple{VectorPriorityQueue}","page":"API reference","title":"DataStructures.dequeue_pair!","text":"dequeue_pair!(pq::VectorPriorityQueue)\n\nRemove and return the pair k => v with lowest priority value v. Amortized complexity O(n).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.enqueue!-Union{Tuple{V}, Tuple{K}, Tuple{HeapPriorityQueue{K, V}, K, V}} where {K, V}","page":"API reference","title":"DataStructures.enqueue!","text":"enqueue!(pq::HeapPriorityQueue, k, v)\n\nInsert k => v into the queue pq. Amortized complexity O(log n).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.enqueue!-Union{Tuple{V}, Tuple{K}, Tuple{SortedVectorPriorityQueue{K, V}, K, V}} where {K, V}","page":"API reference","title":"DataStructures.enqueue!","text":"enqueue!(pq::SortedVectorPriorityQueue, k, v)\n\nInsert k => v into the queue pq. Amortized complexity O(log n).\n\n\n\n\n\n","category":"method"},{"location":"api/#DataStructures.enqueue!-Union{Tuple{V}, Tuple{K}, Tuple{VectorPriorityQueue{K, V}, K, V}} where {K, V}","page":"API reference","title":"DataStructures.enqueue!","text":"enqueue!(pq::VectorPriorityQueue, k, v)\n\nInsert k => v into the queue pq. Amortized complexity O(1).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FastPriorityQueues","category":"page"},{"location":"#FastPriorityQueues.jl","page":"Home","title":"FastPriorityQueues.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for FastPriorityQueues.jl.","category":"page"},{"location":"#Why-this-package?","page":"Home","title":"Why this package?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The standard PriorityQueue provided by DataStructures.jl relies on a dictionary, which can be inefficient in some cases.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There have been a number of Discourse topics on this issue (2020/07, 2021/01, 2021/09), but sofar it looks like alternative implementations are scattered through specific packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goal of the present package is to make some of these alternatives available under a name that is easily discoverable.","category":"page"}]
}
